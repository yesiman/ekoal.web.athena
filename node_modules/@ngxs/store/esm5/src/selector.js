import * as tslib_1 from "tslib";
import { memoize } from './memoize';
import { getValue } from './utils';
import { ensureStoreMetadata, ensureSelectorMetadata } from './internals';
import { getSelectorFn } from './selector-utils';
/**
 * Decorator for memoizing a state selector.
 */
export function Selector(selectors) {
    return function (target, key, descriptor) {
        var metadata = ensureStoreMetadata(target);
        if (descriptor.value !== null) {
            var prev_1 = descriptor.value;
            var wrappedFn = function wrappedSelectorFn() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var returnValue = prev_1.apply(void 0, tslib_1.__spread(args));
                if (returnValue instanceof Function) {
                    var innerMemoizedFn = memoize.apply(null, [returnValue]);
                    return innerMemoizedFn;
                }
                return returnValue;
            };
            var memoizedFn_1 = memoize(wrappedFn);
            var fn = function (state) {
                var results = [];
                // If we are on a state class, get the metadata path
                if (metadata && metadata.path) {
                    results.push(getValue(state, metadata.path));
                }
                // Allow additional selectors if passed
                if (selectors) {
                    results.push.apply(results, tslib_1.__spread(selectors.map(function (a) { return getSelectorFn(a)(state); })));
                }
                // if the lambda tries to access a something on the
                // state that doesn't exist, it will throw a TypeError.
                // since this is quite usual behaviour, we simply return undefined if so.
                try {
                    return memoizedFn_1.apply(void 0, tslib_1.__spread(results));
                }
                catch (ex) {
                    if (ex instanceof TypeError) {
                        return undefined;
                    }
                    throw ex;
                }
            };
            var selectorMetaData = ensureSelectorMetadata(memoizedFn_1);
            selectorMetaData.originalFn = prev_1;
            selectorMetaData.storeMetaData = metadata;
            selectorMetaData.selectFromAppState = fn;
            return {
                configurable: true,
                get: function () {
                    return memoizedFn_1;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}
//# sourceMappingURL=selector.js.map
