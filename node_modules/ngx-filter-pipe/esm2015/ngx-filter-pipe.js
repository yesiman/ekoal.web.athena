import { Pipe, Injectable, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FilterPipe {
    /**
     * @param {?} filter
     * @return {?}
     */
    filterByString(filter) {
        if (filter) {
            filter = filter.toLowerCase();
        }
        return value => {
            return !filter || (value ? ('' + value).toLowerCase().indexOf(filter) !== -1 : false);
        };
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    filterByBoolean(filter) {
        return value => {
            return Boolean(value) === filter;
        };
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    filterByObject(filter) {
        return value => {
            for (let /** @type {?} */ key in filter) {
                if (key === '$or') {
                    if (!this.filterByOr(filter.$or)(this.getValue(value))) {
                        return false;
                    }
                    continue;
                }
                let /** @type {?} */ walker = value;
                let /** @type {?} */ found = false;
                do {
                    if (walker.hasOwnProperty(key) || Object.getOwnPropertyDescriptor(walker, key)) {
                        found = true;
                        break;
                    }
                } while (walker = Object.getPrototypeOf(walker));
                if (!found) {
                    return false;
                }
                let /** @type {?} */ val = this.getValue(value[key]);
                const /** @type {?} */ filterType = typeof filter[key];
                let /** @type {?} */ isMatching;
                if (filterType === 'boolean') {
                    isMatching = this.filterByBoolean(filter[key])(val);
                }
                else if (filterType === 'string') {
                    isMatching = this.filterByString(filter[key])(val);
                }
                else if (filterType === 'object') {
                    isMatching = this.filterByObject(filter[key])(val);
                }
                else {
                    isMatching = this.filterDefault(filter[key])(val);
                }
                if (!isMatching) {
                    return false;
                }
            }
            return true;
        };
    }
    /**
     * Filter value by $or
     * @param {?} filter
     * @return {?}
     */
    filterByOr(filter) {
        return (value) => {
            let /** @type {?} */ hasMatch = false;
            const /** @type {?} */ length = filter.length;
            const /** @type {?} */ arrayComparison = (i) => {
                return value.indexOf(filter[i]) !== -1;
            };
            const /** @type {?} */ otherComparison = (i) => {
                return value === filter[i];
            };
            const /** @type {?} */ comparison = Array.isArray(value) ? arrayComparison : otherComparison;
            for (let /** @type {?} */ i = 0; i < length; i++) {
                if (comparison(i)) {
                    hasMatch = true;
                    break;
                }
            }
            return hasMatch;
        };
    }
    /**
     * Checks function's value if type is function otherwise same value
     * @param {?} value
     * @return {?}
     */
    getValue(value) {
        return typeof value === 'function' ? value() : value;
    }
    /**
     * Defatul filterDefault function
     * @param {?} filter
     * @return {?}
     */
    filterDefault(filter) {
        return (value) => {
            return filter === undefined || filter == value;
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNumber(value) {
        return !isNaN(parseInt(value, 10)) && isFinite(value);
    }
    /**
     * @param {?} array
     * @param {?} filter
     * @return {?}
     */
    transform(array, filter) {
        const /** @type {?} */ type = typeof filter;
        if (!array) {
            return array;
        }
        if (type === 'boolean') {
            return array.filter(this.filterByBoolean(filter));
        }
        if (type === 'string') {
            if (this.isNumber(filter)) {
                return array.filter(this.filterDefault(filter));
            }
            return array.filter(this.filterByString(filter));
        }
        if (type === 'object') {
            return array.filter(this.filterByObject(filter));
        }
        if (type === 'function') {
            return array.filter(filter);
        }
        return array.filter(this.filterDefault(filter));
    }
}
FilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterBy',
                pure: false
            },] },
    { type: Injectable },
];
/** @nocollapse */
FilterPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FilterPipeModule {
}
FilterPipeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FilterPipe],
                providers: [FilterPipe],
                exports: [FilterPipe]
            },] },
];
/** @nocollapse */
FilterPipeModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { FilterPipeModule, FilterPipe };
//# sourceMappingURL=ngx-filter-pipe.js.map
