{
  "version": 3,
  "file": "selector.js",
  "sources": [
    "ng://@ngxs/store/packages/store/src/selector.ts"
  ],
  "sourcesContent": [
    "import { memoize } from './memoize';\nimport { getValue } from './utils';\nimport { ensureStoreMetadata, ensureSelectorMetadata } from './internals';\nimport { getSelectorFn } from './selector-utils';\n\n/**\n * Decorator for memoizing a state selector.\n */\nexport function Selector(selectors?: any[]) {\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\n    const metadata = ensureStoreMetadata(target);\n\n    if (descriptor.value !== null) {\n      const prev = descriptor.value;\n      const wrappedFn = function wrappedSelectorFn(...args) {\n        const returnValue = prev(...args);\n        if (returnValue instanceof Function) {\n          const innerMemoizedFn = memoize.apply(null, [returnValue]);\n          return innerMemoizedFn;\n        }\n        return returnValue;\n      };\n      const memoizedFn = memoize(wrappedFn);\n\n      const fn = state => {\n        const results = [];\n\n        // If we are on a state class, get the metadata path\n        if (metadata && metadata.path) {\n          results.push(getValue(state, metadata.path));\n        }\n\n        // Allow additional selectors if passed\n        if (selectors) {\n          results.push(...selectors.map(a => getSelectorFn(a)(state)));\n        }\n\n        // if the lambda tries to access a something on the\n        // state that doesn't exist, it will throw a TypeError.\n        // since this is quite usual behaviour, we simply return undefined if so.\n        try {\n          return memoizedFn(...results);\n        } catch (ex) {\n          if (ex instanceof TypeError) {\n            return undefined;\n          }\n          throw ex;\n        }\n      };\n\n      const selectorMetaData = ensureSelectorMetadata(memoizedFn);\n      selectorMetaData.originalFn = prev;\n      selectorMetaData.storeMetaData = metadata;\n      selectorMetaData.selectFromAppState = fn;\n\n      return {\n        configurable: true,\n        get() {\n          return memoizedFn;\n        }\n      };\n    } else {\n      throw new Error('Selectors only work on methods');\n    }\n  };\n}\n"
  ],
  "names": [],
  "mappings": "AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AACnC,OAAO,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,MAAM,aAAa,CAAC;AAC1E,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;;;;AAKjD,MAAM,mBAAmB,SAAiB;IACxC,MAAM,CAAC,CAAC,MAAW,EAAE,GAAW,EAAE,UAA8B,EAAE,EAAE;QAClE,MAAM,QAAQ,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;QAE7C,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;YAC9B,MAAM,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC;YAC9B,MAAM,SAAS,GAAG,2BAA2B,GAAG,IAAI;gBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;gBAClC,EAAE,CAAC,CAAC,WAAW,YAAY,QAAQ,CAAC,CAAC,CAAC;oBACpC,MAAM,eAAe,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC3D,MAAM,CAAC,eAAe,CAAC;iBACxB;gBACD,MAAM,CAAC,WAAW,CAAC;aACpB,CAAC;YACF,MAAM,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;YAEtC,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE;gBACjB,MAAM,OAAO,GAAG,EAAE,CAAC;;gBAGnB,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC9B,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;iBAC9C;;gBAGD,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACd,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBAC9D;;;;gBAKD,IAAI,CAAC;oBACH,MAAM,CAAC,UAAU,CAAC,GAAG,OAAO,CAAC,CAAC;iBAC/B;gBAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;oBACZ,EAAE,CAAC,CAAC,EAAE,YAAY,SAAS,CAAC,CAAC,CAAC;wBAC5B,MAAM,CAAC,SAAS,CAAC;qBAClB;oBACD,MAAM,EAAE,CAAC;iBACV;aACF,CAAC;YAEF,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,UAAU,CAAC,CAAC;YAC5D,gBAAgB,CAAC,UAAU,GAAG,IAAI,CAAC;YACnC,gBAAgB,CAAC,aAAa,GAAG,QAAQ,CAAC;YAC1C,gBAAgB,CAAC,kBAAkB,GAAG,EAAE,CAAC;YAEzC,MAAM,CAAC;gBACL,YAAY,EAAE,IAAI;gBAClB,GAAG;oBACD,MAAM,CAAC,UAAU,CAAC;iBACnB;aACF,CAAC;SACH;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;SACnD;KACF,CAAC;CACH"
}
